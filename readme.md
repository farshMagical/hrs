# HRS  
ПО для управления спектрометром высокого разрешения для установки Т15МД. По установленным значениям дисперсии и длины волны устанавливает прибор в рабочее положение. Представляет клиент серверный комплекс программ.

## Функции HRS  
* Включение/выключение прибора  
* Установка значения дисперсии
* Установка значения длины волны
* Отображение состояния подключения, текущего положения, статуса (waiting|busy|calibration) шагового двигателя зеркала, состояния концевиков зеркал
* Отображение состояния подключения, текущего положения, статуса (waiting|busy|calibration) шагового двигателя решеток, состояния концевиков решеток 
* Установка положения зеркал
* Установка положения решеток
* Проведение калибровки 

# Сервер hrs_server 
Сервер - демон, который можно `start`, `stop` и `verbose`. По протоколу websocket передаются данные, которые необходимо мониторить в реальном времени. HTTP POST запросы используются для настройки спектрометра. ~~IP адрес, порт и url пути можно настроить в файле конфигурации hrs_server.~~
* ws://localhost:3000/monitor/mirror - получение данных о состоянии зеркал
* ws://localhost:3000/monitor/grate - получение данных о состоянии зеркал  
  
HTTP POST - клиент отправляет управляющие команды:
* http://localhost:3000/control 
    - Включение/выключение: `{"power":"on"}`, `{"power":"off"}`
    - Установка дисперсии: `{"dispersion":123.456}`
    - Установка длины волны: `{"lambda":123.456}`
    - Проведение калибровки: `{"calibration":true}`
* http://localhost:3000/control/manual 
    - Положение зеркала в градусах: `{"mirror":21.45}`
    - Положение решетки в градусах: `{"grate":21.45}`  
    - Стоп: `{"stop": true}`  
  
### Формат отправляемых сервером пакетов
`{"mirror":  
  {"connection": true|false, "position": 12.34, "limitSwitch": true|false, "status": "waiting|busy|calibration|else"},  
"grade":  
{"connection": true|false, "position": 12.34, "limitSwitch": true|false, "status": "waiting|busy|calibration|else"}
}`  
Для передачи данных используется `json`, библиотека [nlohmann/json](https://github.com/nlohmann/json?tab=readme-ov-file#cmake).  

### Алгоритм калибровки
Первоначальная калибровка выполняется один раз. Она нужна для того, чтобы узнать растояние в шагах шагового двигателя от `нулевого положения` (положение, при котором излучение отражается обратно в источник) до крайнего положения, при котором срабатывают концевики (limitSwitch). Из-за того, что срабатывание концевиков плавающее, это значение будет сохранено в файле конфигурации hrs_server'а.  
В файле конфигурации храняться четыре значения: расстояния от `нулевого положение` до концевиков для каждого из шаговых двигателей и расстояние от `нулевого положения` до `парковки` для каждого из шаговых двигателей.  
`Парковка` - положение, которое занимают шаговые двигатели при включении/выключении. Это необходимо из-за невозможности точного закрепления двигателей на конкретном делении(?) шага.  
Основная калибровка представляет движение шаговых двигателей к крайнему положению, при котором сработают концевики. При срабатывании концевиков текущее положении шаговых двигателей станет равным параметру из файла конфигурации hrs_server'а. Также положение шаговых двигателей будет изменено на N шагов от концевиков.

### Аппаратные ограничения
* Проблема нестабильной работы концевиков (+ не забывать, что там гистерезис у шагового двигателя решетки), мешает точной калибровке (порядок ошибки срабатывания +-100 шагов кажется)
* Дребезг концевика шагового двигателя зеркала. Проблема решена так: в случае возникновения сигнала от концевика ожидаем n мс, а после проверяем сигнал снова. Если сигнала нет, значит был дребезг.

# Клиент
В простейшем случае, клиент представляется собой консольное приложение, которое умеет обращаться по http и ws к серверу, передавая команды. Идея в том, чтобы при необходимости в будущем без проблем интегрировать управление спектрометром в любую SCADA или иную программу управления, в составе которой будет находится спектрометр.

# Переводы рабочих единиц
## Константы шаговых двигателей

# Сборка
* Установка [vcpkg](https://learn.microsoft.com/ru-ru/vcpkg/get_started/get-started?pivots=shell-cmd), [cmake](https://cmake.org/download/), [msvc](https://visualstudio.microsoft.com/ru/downloads/), [llvm](https://github.com/llvm/llvm-project/releases/tag/llvmorg-18.1.8)
* Установка зависимостей с помощью команды `vcpkg install` в дериктории проекта
* mkdir build && cd build && cmake . && cmake --build .

## Установка
`cmake install`  
Проверка корректного нахождения библиотеки NiFPGA.dll

## Логирование

# Работа с сервером в ручном режиме
Для формирования запросов можно использовать утилиты `curl` или `postman`.

### Ссылки
* [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637)
* [NI FPGA guide](https://www.ni.com/docs/en-US/bundle/fpga-interface-c-api-ref/page/capi/fpgac.html) for c/c++ applications
* [Advanced server example](https://www.boost.org/doc/libs/1_85_0/libs/beast/example/advanced/server/advanced_server.cpp)